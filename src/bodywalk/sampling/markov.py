from typing import Callable, Generator

import numpy as np
from numpy.typing import ArrayLike

from .utils import RandomStateLike, check_random_state
from ..geometry import ConvexBody


StepFunction = Callable[[ConvexBody, np.ndarray, np.random.Generator], np.ndarray]

class MarkovChain:
    """Class representing a Markov Chain over a ConvexBody."""

    def __init__(self, step_function: StepFunction,
                 body: ConvexBody,
                 initial_point: ArrayLike):
        """
        Parameters
        ----------
        step_function : StepFunction
            Function generating the next sample of the Markov Chain
        body : ConvexBody
            ConvexBody object to sample from
        initial_point : ArrayLike
            Initial point for Markov Chain

        Raises
        ------
        ValueError
            If initial point and body dimensionality are incompatible
        """
        initial_point = np.array(initial_point, dtype='float', copy=True)

        if initial_point.size != body.dim:
            raise ValueError(
                f"Convex body and initial sample have incompatible sizes: \
                {body.dim} != {initial_point.size}"
            )

        self._body = body
        self._initial_sample = initial_point
        self._step_function = step_function

    @property
    def dim(self) -> int:
        """
        Returns
        -------
        int
            Underlying dimensionality of convex body / samples.
        """
        return self._body.dim

    def generate(self, random_state: RandomStateLike = None) -> Generator[np.ndarray, None, None]:
        """Returns an infinite generator for this Markov Chain.

        Parameters
        ----------
        random_state : None (default), int, or np.random.Generator instance
            The random number generator instance. It can be specified in 3 ways:
                - None: creates a new RandomState instance with unspecified seed
                - int: seed to be used for the RNG. Allows for reproducibility.
                - np.random.Generator instance: a specific Generator instance to be used

        Yields
        ------
        np.ndarray
            The samples generated by this Markov Chain
        """
        random_state = check_random_state(random_state)

        current_sample = self._initial_sample
        while True:
            current_sample = self.__advance(current_sample, n=1, random_state=random_state)
            yield current_sample

    def sample(self, n: int = 1, warmup: int = 1, thin: int = 1, random_state: RandomStateLike = None) -> np.ndarray:
        """Returns a collections of samples from the Markov Chain. Given a Markov Chain {x[0], x[1], x[2], ...},
        a number of samples to compute "n", and a 'warmup' and 'thin' parameters, we return all samples on the
        form x[warmup + i * thin] for 0 <= i < n.

        Parameters
        ----------
        n : int, optional
            Number of samples to return, by default 1
        warmup : int, optional
            Number of initial samples to skip, by default 1. Markov Chains usually have an
            initial warmup mixing time in which sample distribution is far from stationary,
            making it usually effective to ignore those.
        thin : int, optional
            Number of samples to skip before , by default 1
        random_state : None (default), int, or np.random.Generator instance
            The random number generator instance. It can be specified in 3 ways:
                - None: creates a new RandomState instance with unspecified seed
                - int: seed to be used for the RNG. Allows for reproducibility.
                - np.random.Generator instance: a specific Generator instance to be used

        Returns
        -------
        np.ndarray
            A 2-dimensional numpy array in which row "i" corresponds to sample x[warmup + i * thin]

        Raises
        ------
        ValueError
            If n <= 0, warmup < 0, or thin <= 0
        """
        if n <= 0:
            raise ValueError(f"Number of samples 'n' must be positive, but got {n}")

        if warmup < 0:
            raise ValueError(f"'warmup' value must be positive, but got {warmup}")

        if thin <= 0:
            raise ValueError(f"'thin' value must be positive, but got {thin}")

        random_state = check_random_state(random_state)

        samples = np.empty((n, self.dim))
        samples[0] = self.__advance(self._initial_sample, warmup, random_state)
        for i in range(1, n):
            samples[i] = self.__advance(samples[i-1], thin, random_state)

        return samples

    def __advance(self, current_sample: np.ndarray, n: int, random_state: np.random.RandomState) -> None:
        """Advances the Markov Chain to the next sample."""
        for _ in range(n):
            current_sample = self._step_function(
                self._body, current_sample, random_state
            )

        return current_sample
