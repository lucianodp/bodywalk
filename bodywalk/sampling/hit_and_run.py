import numpy as np
from numpy.typing import ArrayLike

from bodywalk.sampling.markov import MarkovChain, generate_markov_chain

from .utils import RandomStateLike
from ..geometry import ConvexBody


def hit_and_run(body: ConvexBody,
                initial_point: ArrayLike,
                random_state: RandomStateLike = None) -> MarkovChain:
    """Generate a Markov Chain inside a convex body converging to the uniform distribution
    via the Hit-and-Run Walk algorithm.

    Parameters
    ----------
    body : ConvexBody
        The convex body to sample from. It requires an implementation of the
        compute_intersection_extremes method.
    initial_point : ArrayLike
        The starting point for the Markov chain. It must be inside the convex body.
    random_state : None (default), int, or np.random.RandomState instance
        The random number generator instance. It can be specified in 3 ways:
            - None: creates a new RandomState instance with unspecified seed
            - int: seed to be used for the RNG. Allows for reproducibility.
            - RandomState instance: a specific RandomState instance to be used

    Yields
    -------
    Generator[np.ndarray]
        A generator yielding the Markov Chain samples generated by the Hit-and-Run strategy.

    Raises
    ------
    ValueError
        If invalid line segment is computed (lower extreme >= upper extreme).

    References
    ----------
        [1] C. J. P. BÃ©lisle, H. E. Romeijn, R. L. Smith. Hit-and-Run Algorithms for Generating Multivariate Distributions
            Mathematics of Operations Research, Vol. 18, No. 2. 1993

        [2] L. Lovasz and S. Vempala. Hit-and-Run is Fast and Fun.
            Technical Report. 2003.
            https://web.cs.elte.hu/~lovasz/logcon-hitrun.pdf
    """
    return generate_markov_chain(hit_and_run_step, body, initial_point, random_state)


def hit_and_run_step(body: ConvexBody, sample: np.ndarray, random_state: np.random.RandomState) -> np.ndarray:
    """Generates the next hit-and-run sample
    """
    random_direction = random_state.normal(size=sample.shape)

    lower, upper = body.compute_intersection_extremes(sample, random_direction)
    if lower >= upper:
        raise RuntimeError(
            f"Lower extreme must be smaller than upper extreme, but got {lower} >= {upper}"
        )

    return sample + random_state.uniform(lower, upper) * random_direction
