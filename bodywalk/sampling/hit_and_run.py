from typing import Generator

import numpy as np
from numpy.typing import ArrayLike

from .utils import RandomStateLike, check_random_state
from ..geometry import ConvexBody


def hit_and_run(body: ConvexBody,
                initial_point: ArrayLike,
                random_state: RandomStateLike = None) -> Generator[np.ndarray, None, None]:
    """Generate a Markov Chain inside a convex body converging to the uniform distribution
    via the Hit-and-Run Walk algorithm.

    Parameters
    ----------
    body : ConvexBody
        The convex body to sample from. It requires an implementation of the
        compute_intersection_extremes method.
    initial_point : ArrayLike
        The starting point for the Markov chain. It must be inside the convex body.
    random_state : None (default), int, or np.random.RandomState instance
        The random number generator instance. It can be specified in 3 ways:
            - None: creates a new RandomState instance with unspecified seed
            - int: seed to be used for the RNG. Allows for reproducibility.
            - RandomState instance: a specific RandomState instance to be used

    Yields
    -------
    Generator[np.ndarray, None, None]
        The Markov Chain samples generated by the sampling algorithm.

    Raises
    ------
    ValueError
        If invalid line segment is computed (lower extreme >= upper extreme).

    References
    ----------
        [1] C. J. P. BÃ©lisle, H. E. Romeijn, R. L. Smith. Hit-and-Run Algorithms for Generating Multivariate Distributions
            Mathematics of Operations Research, Vol. 18, No. 2. 1993

        [2] L. Lovasz and S. Vempala. Hit-and-Run is Fast and Fun.
            Technical Report. 2003.
            https://web.cs.elte.hu/~lovasz/logcon-hitrun.pdf
    """
    random_state = check_random_state(random_state)

    sample = np.array(initial_point, dtype='float', copy=True)

    while True:
        random_direction = random_state.normal(size=sample.shape)

        lower, upper = body.compute_intersection_extremes(sample, random_direction)
        if lower >= upper:
            raise ValueError(f"Lower extreme must be smaller than upper extreme, but {lower} >= {upper}")

        sample += random_state.uniform(lower, upper) * random_direction

        yield sample.copy()  # return a copy because 'sample' is modified at every iteration
